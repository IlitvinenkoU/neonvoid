<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<meta name="theme-color" content="#05020b" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Neon Void" />
<title>Neon Void</title>
<link rel="manifest" href="manifest.json" />
<link rel="apple-touch-icon" href="icon-192.png" />
<style>
  :root {
    --bg: #05020b;
    --neon-cyan: #37f9ff;
    --neon-pink: #ff3df5;
    --neon-purple: #7b5cff;
    --neon-green: #7dff6a;
  }
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: var(--bg);
    overflow: hidden;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    overscroll-behavior: none;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: auto;
    touch-action: none;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(() => {
  'use strict';

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let w = 0;
  let h = 0;
  function resize() {
    w = canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
    h = canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
    ctx.imageSmoothingEnabled = true;
  }
  window.addEventListener('resize', resize);
  resize();

  let audio = null;
  const isTouchDevice = window.matchMedia('(pointer: coarse)').matches || 'ontouchstart' in window;
  const settings = {
    autoFire: isTouchDevice,
    portraitOnly: isTouchDevice
  };
  const input = {
    moveX: 0,
    moveY: 0,
    fire: false,
    usingTouch: false
  };
  const joystick = {
    active: false,
    id: null,
    startX: 0,
    startY: 0,
    x: 0,
    y: 0,
    radius: 55
  };
  const keys = Object.create(null);
  window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (audio) audio.ensure();
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) {
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e) => { keys[e.code] = false; });
  window.addEventListener('blur', () => {
    keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = keys.Space = false;
    input.moveX = 0;
    input.moveY = 0;
    input.fire = false;
    joystick.active = false;
  });

  function haptic(pattern) {
    if (navigator.vibrate) navigator.vibrate(pattern);
  }

  function rand(min, max) { return Math.random() * (max - min) + min; }
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  class AudioSystem {
    constructor() {
      this.ctx = null;
      this.master = null;
      this.started = false;
    }
    ensure() {
      if (this.started) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;
      this.ctx = new AudioCtx();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.28;
      this.master.connect(this.ctx.destination);
      this.startBackground();
      this.started = true;
    }
    startBackground() {
      const ctx = this.ctx;
      const bass = ctx.createOscillator();
      const bassGain = ctx.createGain();
      const bassFilter = ctx.createBiquadFilter();
      bass.type = 'sawtooth';
      bass.frequency.value = 55;
      bassGain.gain.value = 0.08;
      bassFilter.type = 'lowpass';
      bassFilter.frequency.value = 200;
      bass.connect(bassFilter).connect(bassGain).connect(this.master);

      const pad = ctx.createOscillator();
      const padGain = ctx.createGain();
      const padFilter = ctx.createBiquadFilter();
      pad.type = 'triangle';
      pad.frequency.value = 110;
      padGain.gain.value = 0.05;
      padFilter.type = 'lowpass';
      padFilter.frequency.value = 900;
      padFilter.Q.value = 0.7;
      pad.connect(padFilter).connect(padGain).connect(this.master);

      const lfo = ctx.createOscillator();
      const lfoGain = ctx.createGain();
      lfo.frequency.value = 0.08;
      lfoGain.gain.value = 200;
      lfo.connect(lfoGain).connect(padFilter.frequency);

      bass.start();
      pad.start();
      lfo.start();
    }
    playShoot(level) {
      if (!this.ctx) this.ensure();
      if (!this.ctx) return;
      const ctx = this.ctx;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const type = level >= 3 ? 'square' : 'sawtooth';
      const base = 420 + level * 90;
      osc.type = type;
      osc.frequency.setValueAtTime(base, now);
      osc.frequency.exponentialRampToValueAtTime(base * 0.35, now + 0.14);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.35, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);
      osc.connect(gain).connect(this.master);
      osc.start(now);
      osc.stop(now + 0.18);
    }
    playPowerUp() {
      if (!this.ctx) this.ensure();
      if (!this.ctx) return;
      const ctx = this.ctx;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(520, now);
      osc.frequency.exponentialRampToValueAtTime(1040, now + 0.12);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.35, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
      osc.connect(gain).connect(this.master);
      osc.start(now);
      osc.stop(now + 0.22);
    }
  }

  audio = new AudioSystem();
  window.addEventListener('pointerdown', () => audio.ensure(), { once: true });
  const isIos = /iphone|ipad|ipod/i.test(navigator.userAgent);
  let installPrompt = null;
  let canInstall = false;
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    installPrompt = e;
    canInstall = true;
  });
  const isStandalone = () => window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;

  class Star {
    constructor() { this.reset(true); }
    reset(initial = false) {
      this.x = Math.random() * w / devicePixelRatio;
      this.y = initial ? Math.random() * h / devicePixelRatio : -20;
      this.z = Math.random() * 1 + 0.2;
      this.speed = 30 + 120 * this.z;
      this.len = 10 * this.z;
    }
    update(dt) {
      this.y += this.speed * dt;
      if (this.y > h / devicePixelRatio + 30) this.reset();
    }
    draw(ctx) {
      ctx.strokeStyle = `rgba(80, 200, 255, ${0.25 + this.z * 0.6})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x, this.y - this.len);
      ctx.stroke();
    }
  }

  class Particle {
    constructor(x, y, color, size, life) {
      this.x = x; this.y = y;
      this.vx = rand(-120, 120);
      this.vy = rand(-120, 120);
      this.life = life;
      this.maxLife = life;
      this.size = size;
      this.color = color;
    }
    update(dt) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.life -= dt;
    }
    draw(ctx) {
      const t = Math.max(0, this.life / this.maxLife);
      ctx.save();
      ctx.globalAlpha = t;
      ctx.shadowBlur = 12;
      ctx.shadowColor = this.color;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size * t, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  class PowerUp {
    constructor(x, y, type) {
      this.x = x; this.y = y;
      this.type = type;
      this.vx = rand(-20, 20);
      this.vy = rand(40, 80);
      this.r = 12;
      this.rot = rand(0, Math.PI * 2);
      this.vr = rand(-2, 2);
      this.life = 10;
    }
    update(dt) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rot += this.vr * dt;
      this.life -= dt;
    }
    draw(ctx) {
      let color = '#7dff6a';
      if (this.type === 'weapon') color = '#ffd36a';
      if (this.type === 'speed') color = '#37f9ff';
      if (this.type === 'shield') color = '#7b5cff';
      if (this.type === 'heal') color = '#ff3df5';
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rot);
      ctx.shadowBlur = 16;
      ctx.shadowColor = color;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      if (this.type === 'weapon') {
        ctx.beginPath();
        ctx.rect(-10, -8, 20, 16);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-10, -2);
        ctx.lineTo(10, -2);
        ctx.moveTo(-10, 4);
        ctx.lineTo(10, 4);
        ctx.stroke();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(-5, -6, 2, 0, Math.PI * 2);
        ctx.arc(0, -6, 2, 0, Math.PI * 2);
        ctx.arc(5, -6, 2, 0, Math.PI * 2);
        ctx.fill();
      } else if (this.type === 'speed') {
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(6, -2);
        ctx.lineTo(6, 6);
        ctx.lineTo(-6, 6);
        ctx.lineTo(-6, -2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-6, 2);
        ctx.lineTo(-10, 6);
        ctx.moveTo(6, 2);
        ctx.lineTo(10, 6);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-3, 6);
        ctx.lineTo(0, 12);
        ctx.lineTo(3, 6);
        ctx.stroke();
      } else if (this.type === 'shield') {
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(8, -4);
        ctx.lineTo(6, 8);
        ctx.lineTo(0, 12);
        ctx.lineTo(-6, 8);
        ctx.lineTo(-8, -4);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -8);
        ctx.lineTo(0, 8);
        ctx.stroke();
      } else {
        ctx.strokeStyle = '#ff3d3d';
        ctx.shadowColor = '#ff3d3d';
        ctx.beginPath();
        ctx.rect(-10, -10, 20, 20);
        ctx.stroke();
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, -6);
        ctx.lineTo(0, 6);
        ctx.moveTo(-6, 0);
        ctx.lineTo(6, 0);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  class Bullet {
    constructor(x, y, vx, vy, level) {
      const styles = [
        { color: '#6cf6ff', size: 3, damage: 1, speed: 420 },
        { color: '#ff75f0', size: 3.5, damage: 1, speed: 450 },
        { color: '#a87bff', size: 4, damage: 1.2, speed: 440 },
        { color: '#7dff6a', size: 3, damage: 1.1, speed: 520 },
        { color: '#ffd36a', size: 6, damage: 3, speed: 360 }
      ];
      const s = styles[level];
      this.x = x; this.y = y;
      this.vx = vx; this.vy = vy;
      this.r = s.size;
      this.damage = s.damage;
      this.color = s.color;
      this.life = 2.2;
      this.glow = s.size * 4;
    }
    update(dt) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.life -= dt;
    }
    draw(ctx) {
      ctx.save();
      ctx.shadowBlur = this.glow;
      ctx.shadowColor = this.color;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  class EnemyBullet {
    constructor(x, y, vx, vy, color) {
      this.x = x; this.y = y;
      this.vx = vx; this.vy = vy;
      this.r = 3;
      this.color = color;
      this.life = 4;
      this.glow = 10;
    }
    update(dt) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.life -= dt;
    }
    draw(ctx) {
      ctx.save();
      ctx.shadowBlur = this.glow;
      ctx.shadowColor = this.color;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  class Enemy {
    constructor(type, round, x, y) {
      this.type = type;
      this.round = round;
      this.x = x; this.y = y;
      this.vx = 0; this.vy = 0;
      this.baseSpeed = 40 + round * 8;
      this.radius = 12;
      this.hp = 2;
      this.t = Math.random() * 10;
      this.phase = Math.random() * Math.PI * 2;
      this.cooldown = rand(0.6, 1.4);
      this.sway = rand(50, 90);
      this.spin = rand(-2.2, 2.2);
      if (type === 'kamikaze') {
        this.radius = 12;
        this.hp = 1 + round * 0.15;
      } else if (type === 'strafer') {
        this.radius = 16;
        this.hp = 2 + round * 0.2;
        this.vx = rand(-60, 60);
      } else if (type === 'tanky') {
        this.radius = 22;
        this.hp = 5 + round * 0.4;
      } else if (type === 'weaver') {
        this.radius = 14;
        this.hp = 2 + round * 0.15;
        this.sway = rand(80, 120);
      } else if (type === 'sniper') {
        this.radius = 18;
        this.hp = 3 + round * 0.2;
        this.vy = this.baseSpeed * 0.35;
      }
    }
    update(dt, player, game) {
      this.t += dt;
      if (this.type === 'kamikaze') {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const d = Math.hypot(dx, dy) || 1;
        const ang = Math.atan2(dy, dx) + Math.sin(this.t * 3 + this.phase) * 0.25;
        const speed = this.baseSpeed + 40;
        this.vx = Math.cos(ang) * speed;
        this.vy = Math.sin(ang) * speed;
      } else if (this.type === 'strafer') {
        this.vy = this.baseSpeed * 0.75;
        this.vx = Math.sin(this.t * 2.2 + this.phase) * this.sway;
        this.cooldown -= dt;
        if (this.cooldown <= 0 && game) {
          this.cooldown = Math.max(0.7, 1.4 - this.round * 0.05);
          game.spawnEnemyBullet(this.x, this.y + this.radius, player, 240, '#37f9ff');
        }
      } else if (this.type === 'tanky') {
        this.vy = this.baseSpeed * 0.45;
        this.vx = Math.cos(this.t * 0.6 + this.phase) * 20;
        this.cooldown -= dt;
        if (this.cooldown <= 0 && game) {
          this.cooldown = Math.max(0.9, 1.8 - this.round * 0.04);
          game.spawnEnemyBullet(this.x - 8, this.y + this.radius, player, 210, '#7b5cff', -0.08);
          game.spawnEnemyBullet(this.x + 8, this.y + this.radius, player, 210, '#7b5cff', 0.08);
        }
      } else if (this.type === 'weaver') {
        this.vy = this.baseSpeed * 0.85;
        this.vx = Math.sin(this.t * 3.2 + this.phase) * this.sway;
        this.cooldown -= dt;
        if (this.cooldown <= 0 && game) {
          this.cooldown = Math.max(0.7, 1.3 - this.round * 0.04);
          game.spawnEnemyBullet(this.x, this.y + this.radius, player, 200, '#a87bff', -0.18);
          game.spawnEnemyBullet(this.x, this.y + this.radius, player, 200, '#a87bff', 0);
          game.spawnEnemyBullet(this.x, this.y + this.radius, player, 200, '#a87bff', 0.18);
        }
      } else if (this.type === 'sniper') {
        this.vy = this.vy || this.baseSpeed * 0.35;
        if (this.y > 140) this.vy = this.baseSpeed * 0.1;
        this.cooldown -= dt;
        if (this.cooldown <= 0 && game) {
          this.cooldown = Math.max(1.2, 2.2 - this.round * 0.05);
          game.spawnEnemyBullet(this.x, this.y + this.radius, player, 320, '#ffd36a');
        }
      }
      this.x += this.vx * dt;
      this.y += this.vy * dt;
    }
    draw(ctx) {
      ctx.save();
      ctx.shadowBlur = 16;
      if (this.type === 'kamikaze') ctx.shadowColor = '#ff3df5';
      if (this.type === 'strafer') ctx.shadowColor = '#37f9ff';
      if (this.type === 'tanky') ctx.shadowColor = '#7b5cff';
      if (this.type === 'weaver') ctx.shadowColor = '#a87bff';
      if (this.type === 'sniper') ctx.shadowColor = '#ffd36a';
      ctx.strokeStyle = ctx.shadowColor;
      ctx.lineWidth = 2;
      if (this.type === 'kamikaze') {
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - this.radius);
        ctx.lineTo(this.x - this.radius, this.y + this.radius);
        ctx.lineTo(this.x + this.radius, this.y + this.radius);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - this.radius * 0.6);
        ctx.lineTo(this.x, this.y + this.radius * 0.8);
        ctx.stroke();
      } else if (this.type === 'strafer') {
        ctx.beginPath();
        ctx.moveTo(this.x - this.radius, this.y);
        ctx.lineTo(this.x, this.y - this.radius);
        ctx.lineTo(this.x + this.radius, this.y);
        ctx.lineTo(this.x, this.y + this.radius);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x - this.radius * 1.2, this.y + 6);
        ctx.lineTo(this.x + this.radius * 1.2, this.y + 6);
        ctx.stroke();
      } else if (this.type === 'tanky') {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius + 6 + Math.sin(this.t * 2) * 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.moveTo(this.x - this.radius, this.y);
        ctx.lineTo(this.x + this.radius, this.y);
        ctx.stroke();
      } else if (this.type === 'weaver') {
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - this.radius);
        ctx.lineTo(this.x - this.radius, this.y);
        ctx.lineTo(this.x, this.y + this.radius);
        ctx.lineTo(this.x + this.radius, this.y);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
        ctx.stroke();
      } else if (this.type === 'sniper') {
        ctx.beginPath();
        ctx.rect(this.x - this.radius, this.y - this.radius * 0.6, this.radius * 2, this.radius * 1.2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - this.radius);
        ctx.lineTo(this.x, this.y + this.radius);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  class Boss {
    constructor() {
      this.x = w / devicePixelRatio / 2;
      this.y = 120;
      this.vx = 60;
      this.t = 0;
      this.hp = 120;
      this.maxHp = 120;
      this.phase = 1;
      this.attackTimer = 2.2;
      this.telegraph = 0;
      this.pendingAttack = null;
      this.hitboxes = [
        { ox: 0, oy: 0, r: 45 },
        { ox: -60, oy: 20, r: 28 },
        { ox: 60, oy: 20, r: 28 },
        { ox: 0, oy: 50, r: 20 }
      ];
      this.core = { ox: 0, oy: 20, r: 14 };
    }
    update(dt, game, player) {
      this.t += dt;
      const hpPct = this.hp / this.maxHp;
      this.phase = hpPct > 0.7 ? 1 : hpPct > 0.35 ? 2 : 3;
      const baseSpeed = this.phase === 1 ? 60 : this.phase === 2 ? 90 : 120;
      this.x += this.vx * dt;
      this.y = 110 + Math.sin(this.t * 1.4) * 8;
      if (this.x < 120 || this.x > w / devicePixelRatio - 120) this.vx = -this.vx;
      this.vx = Math.sign(this.vx || 1) * baseSpeed;

      if (this.telegraph > 0) {
        this.telegraph -= dt;
        if (this.telegraph <= 0 && this.pendingAttack) {
          this.fireAttack(game, player);
          this.pendingAttack = null;
          this.attackTimer = this.phase === 3 ? 1.2 : 1.6;
        }
      } else {
        this.attackTimer -= dt;
        if (this.attackTimer <= 0) {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const ang = Math.atan2(dy, dx);
          if (this.phase === 1) {
            this.pendingAttack = { type: 'aim', ang };
            this.telegraph = 0.6;
          } else if (this.phase === 2) {
            this.pendingAttack = Math.random() > 0.5 ? { type: 'radial' } : { type: 'burst', ang };
            this.telegraph = 0.7;
          } else {
            this.pendingAttack = Math.random() > 0.5 ? { type: 'spiral' } : { type: 'cross', ang };
            this.telegraph = 0.75;
          }
        }
      }
    }
    fireAttack(game, player) {
      if (!game) return;
      if (!this.pendingAttack) return;
      const type = this.pendingAttack.type;
      if (type === 'aim') {
        const ang = this.pendingAttack.ang;
        game.spawnBossBullet(this.x, this.y + 20, ang - 0.08, 260, '#ff3df5');
        game.spawnBossBullet(this.x, this.y + 20, ang, 260, '#ff3df5');
        game.spawnBossBullet(this.x, this.y + 20, ang + 0.08, 260, '#ff3df5');
      } else if (type === 'burst') {
        const ang = this.pendingAttack.ang;
        for (let i = -2; i <= 2; i++) {
          game.spawnBossBullet(this.x, this.y + 20, ang + i * 0.09, 300, '#37f9ff');
        }
      } else if (type === 'radial') {
        for (let i = 0; i < 12; i++) {
          const a = (i / 12) * Math.PI * 2;
          game.spawnBossBullet(this.x, this.y + 20, a, 220, '#7b5cff');
        }
      } else if (type === 'spiral') {
        const base = this.t * 3;
        for (let i = 0; i < 14; i++) {
          const a = base + (i / 14) * Math.PI * 2;
          game.spawnBossBullet(this.x, this.y + 20, a, 240, '#ffd36a');
        }
      } else if (type === 'cross') {
        const ang = this.pendingAttack.ang;
        game.spawnBossBullet(this.x, this.y + 20, ang, 320, '#ff3df5');
        game.spawnBossBullet(this.x, this.y + 20, ang + Math.PI / 2, 220, '#ff3df5');
        game.spawnBossBullet(this.x, this.y + 20, ang - Math.PI / 2, 220, '#ff3df5');
        game.spawnBossBullet(this.x, this.y + 20, ang + Math.PI, 220, '#ff3df5');
      }
    }
    draw(ctx) {
      ctx.save();
      ctx.shadowBlur = 28;
      ctx.shadowColor = '#ff3df5';
      ctx.strokeStyle = '#ff3df5';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(this.x - 90, this.y + 40);
      ctx.lineTo(this.x, this.y - 40);
      ctx.lineTo(this.x + 90, this.y + 40);
      ctx.lineTo(this.x, this.y + 80);
      ctx.closePath();
      ctx.stroke();
      ctx.shadowColor = '#37f9ff';
      ctx.strokeStyle = '#37f9ff';
      for (const hb of this.hitboxes) {
        ctx.beginPath();
        ctx.arc(this.x + hb.ox, this.y + hb.oy, hb.r, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.shadowColor = '#ffd36a';
      ctx.strokeStyle = '#ffd36a';
      ctx.beginPath();
      ctx.arc(this.x + this.core.ox, this.y + this.core.oy, this.core.r, 0, Math.PI * 2);
      ctx.stroke();

      if (this.telegraph > 0 && this.pendingAttack) {
        ctx.save();
        ctx.globalAlpha = 0.4 + this.telegraph * 0.4;
        ctx.strokeStyle = '#ffd36a';
        ctx.shadowColor = '#ffd36a';
        ctx.lineWidth = 2;
        if (this.pendingAttack.type === 'aim' || this.pendingAttack.type === 'burst' || this.pendingAttack.type === 'cross') {
          const ang = this.pendingAttack.ang || 0;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y + 20);
          ctx.lineTo(this.x + Math.cos(ang) * 400, this.y + Math.sin(ang) * 400);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.arc(this.x, this.y + 20, 90, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }
      ctx.restore();
    }
  }

  class Asteroid {
    constructor() {
      this.reset(true);
    }
    reset(initial = false) {
      this.x = Math.random() * w / devicePixelRatio;
      this.y = initial ? Math.random() * h / devicePixelRatio : -50;
      this.r = rand(16, 36);
      this.vx = rand(-30, 30);
      this.vy = rand(30, 80);
      this.rot = rand(0, Math.PI * 2);
      this.vr = rand(-1, 1);
    }
    update(dt) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rot += this.vr * dt;
      if (this.y > h / devicePixelRatio + 60) this.reset();
      if (this.x < -60) this.x = w / devicePixelRatio + 60;
      if (this.x > w / devicePixelRatio + 60) this.x = -60;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rot);
      ctx.shadowBlur = 10;
      ctx.shadowColor = '#7b5cff';
      ctx.strokeStyle = '#7b5cff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 7; i++) {
        const a = (i / 7) * Math.PI * 2;
        const rr = this.r + rand(-6, 6);
        ctx.lineTo(Math.cos(a) * rr, Math.sin(a) * rr);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
  }

  class Beacon {
    constructor() {
      this.x = w / devicePixelRatio / 2;
      this.y = h / devicePixelRatio - 80;
      this.r = 32;
      this.health = 120;
      this.maxHealth = 120;
      this.t = 0;
    }
    update(dt) {
      this.t += dt;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#37f9ff';
      ctx.strokeStyle = '#37f9ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, this.r + Math.sin(this.t * 2) * 2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowColor = '#ff3df5';
      ctx.strokeStyle = '#ff3df5';
      ctx.beginPath();
      ctx.moveTo(-12, 0);
      ctx.lineTo(12, 0);
      ctx.moveTo(0, -12);
      ctx.lineTo(0, 12);
      ctx.stroke();
      ctx.restore();
    }
  }

  class Drone {
    constructor(index) {
      this.index = index;
      this.angle = rand(0, Math.PI * 2);
      this.radius = 26;
      this.cooldown = rand(0.1, 0.4);
      this.x = 0;
      this.y = 0;
    }
    update(dt, player) {
      this.angle += dt * (2 + this.index * 0.3);
      this.x = player.x + Math.cos(this.angle) * this.radius;
      this.y = player.y + Math.sin(this.angle) * (this.radius * 0.7);
      this.cooldown -= dt;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.shadowBlur = 12;
      ctx.shadowColor = '#7dff6a';
      ctx.strokeStyle = '#7dff6a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, 6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-8, 0);
      ctx.lineTo(8, 0);
      ctx.stroke();
      ctx.restore();
    }
  }

  class Player {
    constructor() {
      this.x = w / devicePixelRatio / 2;
      this.y = h / devicePixelRatio - 120;
      this.vx = 0; this.vy = 0;
      this.ax = 0; this.ay = 0;
      this.maxSpeed = 280;
      this.accel = 800;
      this.friction = 0.9;
      this.r = 14;
      this.cooldown = 0;
      this.health = 100;
      this.maxHealth = 100;
      this.hits = 0;
      this.weaponLevel = 0;
      this.power = { weapon: 0, speed: 0, shield: 0 };
      this.powerBonus = { weapon: 0, speed: 0, shield: 0 };
      this.perkDamage = 0;
      this.perkFireRate = 0;
      this.perkMagnet = 0;
      this.invuln = 0;
    }
    update(dt, game, inputState) {
      this.power.weapon = Math.max(0, this.power.weapon - dt);
      this.power.speed = Math.max(0, this.power.speed - dt);
      this.power.shield = Math.max(0, this.power.shield - dt);
      this.invuln = Math.max(0, this.invuln - dt);

      const ix = inputState.moveX;
      const iy = inputState.moveY;
      const speedMult = this.power.speed > 0 ? 1.6 : 1;
      this.ax = ix * this.accel * speedMult;
      this.ay = iy * this.accel * speedMult;
      this.vx += this.ax * dt;
      this.vy += this.ay * dt;
      this.vx *= Math.pow(this.friction, dt * 60);
      this.vy *= Math.pow(this.friction, dt * 60);
      const sp = Math.hypot(this.vx, this.vy);
      const maxSpeed = this.maxSpeed * speedMult;
      if (sp > maxSpeed) {
        this.vx = (this.vx / sp) * maxSpeed;
        this.vy = (this.vy / sp) * maxSpeed;
      }
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.x = clamp(this.x, 30, w / devicePixelRatio - 30);
      this.y = clamp(this.y, 40, h / devicePixelRatio - 40);

      this.weaponLevel = Math.min(4, Math.floor(this.hits / 5));
      this.cooldown -= dt;
      const wantsFire = (inputState.fire || settings.autoFire || keys.Space) && !game.isOver() && game.state === 'play';
      if (wantsFire && this.cooldown <= 0) {
        this.shoot(game);
      }
    }
    shoot(game) {
      const level = this.power.weapon > 0 ? 4 : this.weaponLevel;
      let rate = 0.25;
      if (level === 3) rate = 0.12;
      if (level === 4) rate = this.power.weapon > 0 ? 0.1 : 0.35;
      rate *= (1 - this.perkFireRate);
      this.cooldown = Math.max(0.06, rate);
      if (audio) audio.playShoot(level);

      const baseSpeed = level === 4 ? 360 : 480;
      const bullets = [];
      if (level === 0) {
        bullets.push(new Bullet(this.x, this.y - 20, 0, -baseSpeed, level));
      } else if (level === 1) {
        bullets.push(new Bullet(this.x - 6, this.y - 18, 0, -baseSpeed, level));
        bullets.push(new Bullet(this.x + 6, this.y - 18, 0, -baseSpeed, level));
      } else if (level === 2) {
        bullets.push(new Bullet(this.x, this.y - 20, -40, -baseSpeed, level));
        bullets.push(new Bullet(this.x, this.y - 20, 0, -baseSpeed, level));
        bullets.push(new Bullet(this.x, this.y - 20, 40, -baseSpeed, level));
      } else if (level === 3) {
        bullets.push(new Bullet(this.x, this.y - 20, 0, -baseSpeed, level));
      } else {
        bullets.push(new Bullet(this.x, this.y - 24, 0, -baseSpeed, level));
        if (this.power.weapon > 0) {
          bullets.push(new Bullet(this.x - 10, this.y - 22, -40, -baseSpeed, level));
          bullets.push(new Bullet(this.x + 10, this.y - 22, 40, -baseSpeed, level));
        }
      }
      for (const b of bullets) {
        b.damage *= (1 + this.perkDamage);
      }
      game.bullets.push(...bullets);
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      if (this.invuln > 0) {
        ctx.globalAlpha = 0.6 + Math.sin(performance.now() * 0.02) * 0.2;
      }
      ctx.shadowBlur = 18;
      ctx.shadowColor = this.power.speed > 0 ? '#37f9ff' : '#37f9ff';
      ctx.strokeStyle = '#37f9ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -18);
      ctx.lineTo(-12, 14);
      ctx.lineTo(0, 8);
      ctx.lineTo(12, 14);
      ctx.closePath();
      ctx.stroke();
      ctx.shadowColor = '#ff3df5';
      ctx.strokeStyle = '#ff3df5';
      ctx.beginPath();
      ctx.moveTo(0, 8);
      ctx.lineTo(0, 22);
      ctx.stroke();
      if (this.power.weapon > 0) {
        ctx.shadowColor = '#ffd36a';
        ctx.strokeStyle = '#ffd36a';
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(0, -2, 22, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      if (this.power.shield > 0) {
        ctx.shadowColor = '#7b5cff';
        ctx.strokeStyle = '#7b5cff';
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(0, 2, 20, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }
  }

  class Game {
    constructor() {
      this.stars = Array.from({ length: 140 }, () => new Star());
      this.player = new Player();
      this.bullets = [];
      this.enemyBullets = [];
      this.enemies = [];
      this.powerUps = [];
      this.particles = [];
      this.asteroids = Array.from({ length: 5 }, () => new Asteroid());
      this.drones = [];
      this.beacon = null;
      this.mission = null;
      this.round = 1;
      this.score = 0;
      this.killed = 0;
      this.spawnTimer = 0;
      this.roundGoal = this.getRoundGoal();
      this.boss = null;
      this.shake = 0;
      this.shakePower = 0;
      this.comboCount = 0;
      this.comboTimer = 0;
      this.glitch = 0;
      this.upgradePool = this.buildUpgradePool();
      this.upgradeChoices = [];
      this.pendingRound = null;
      this.state = 'intro';
      this.roundBanner = 2;
      this.tutorial = 5.5;
      this.setupRound(this.round);
    }
    getRoundGoal() {
      return 8 + this.round * 3;
    }
    buildUpgradePool() {
      return [
        {
          id: 'dmg',
          name: 'Overclock Rounds',
          desc: '+20% damage',
          weight: 1,
          apply: (g) => { g.player.perkDamage += 0.2; }
        },
        {
          id: 'firerate',
          name: 'Capacitor Rush',
          desc: '-12% cooldown',
          weight: 1,
          apply: (g) => { g.player.perkFireRate = Math.min(0.5, g.player.perkFireRate + 0.12); }
        },
        {
          id: 'maxhp',
          name: 'Reinforced Hull',
          desc: '+20 max health',
          weight: 0.9,
          apply: (g) => {
            g.player.maxHealth += 20;
            g.player.health = Math.min(g.player.maxHealth, g.player.health + 20);
          }
        },
        {
          id: 'magnet',
          name: 'Vector Pull',
          desc: 'Power-ups magnetize',
          weight: 0.7,
          apply: (g) => { g.player.perkMagnet = Math.min(220, g.player.perkMagnet + 80); }
        },
        {
          id: 'weaponboost',
          name: 'Weapon Catalyst',
          desc: '+3s super weapon',
          weight: 0.6,
          apply: (g) => { g.player.powerBonus.weapon += 3; }
        },
        {
          id: 'speedboost',
          name: 'Afterburn Node',
          desc: '+2s super speed',
          weight: 0.6,
          apply: (g) => { g.player.powerBonus.speed += 2; }
        },
        {
          id: 'shieldboost',
          name: 'Aegis Circuit',
          desc: '+2s super shield',
          weight: 0.6,
          apply: (g) => { g.player.powerBonus.shield += 2; }
        },
        {
          id: 'drone',
          name: 'Drone Wing',
          desc: 'Add support drone',
          weight: 0.35,
          apply: (g) => {
            if (g.drones.length < 3) g.drones.push(new Drone(g.drones.length));
          }
        }
      ];
    }
    rollUpgrades(count) {
      const picks = [];
      const pool = this.upgradePool.slice();
      while (picks.length < count && pool.length > 0) {
        const total = pool.reduce((sum, u) => sum + u.weight, 0);
        let roll = Math.random() * total;
        let pickedIndex = 0;
        for (let i = 0; i < pool.length; i++) {
          roll -= pool[i].weight;
          if (roll <= 0) { pickedIndex = i; break; }
        }
        picks.push(pool.splice(pickedIndex, 1)[0]);
      }
      return picks;
    }
    setupRound(round) {
      this.roundGoal = 8 + round * 3;
      this.mission = { type: 'eliminate', target: this.roundGoal, timer: 0, eliteKills: 0 };
      this.beacon = null;
      if (round >= 10) {
        this.mission.type = 'boss';
        return;
      }
      if (round === 2 || round === 6) {
        this.mission.type = 'defend';
        this.mission.timer = 22 + round * 1.2;
        this.beacon = new Beacon();
      } else if (round === 3 || round === 8) {
        this.mission.type = 'assault';
        this.mission.target = 3 + Math.floor(round / 2);
      } else if (round === 5 || round === 9) {
        this.mission.type = 'survive';
        this.mission.timer = 20 + round * 1.4;
      }
    }
    enterUpgrade() {
      this.state = 'upgrade';
      this.pendingRound = this.round + 1;
      this.upgradeChoices = this.rollUpgrades(3);
      this.enemies = [];
      this.enemyBullets = [];
      this.bullets = [];
      this.powerUps = [];
      this.beacon = null;
      this.spawnTimer = 0;
    }
    handleUpgradeTap(x, y, width, height) {
      if (this.state !== 'upgrade') return;
      const startY = height / 2 - 70;
      const cardW = 320;
      const cardH = 40;
      const centerX = width / 2;
      for (let i = 0; i < this.upgradeChoices.length; i++) {
        const y0 = startY + i * 52 - 10;
        const x0 = centerX - cardW / 2;
        if (x >= x0 && x <= x0 + cardW && y >= y0 && y <= y0 + cardH) {
          this.applyUpgrade(i);
          break;
        }
      }
    }
    applyUpgrade(index) {
      const choice = this.upgradeChoices[index];
      if (!choice) return;
      choice.apply(this);
      this.round = this.pendingRound;
      this.killed = 0;
      this.setupRound(this.round);
      this.roundBanner = 2.2;
      this.state = 'play';
      this.pendingRound = null;
      haptic([10, 30, 10]);
    }
    getComboMult() {
      return 1 + Math.min(2.5, this.comboCount * 0.05);
    }
    addKillScore(base) {
      this.comboCount += 1;
      this.comboTimer = 3.2;
      const mult = this.getComboMult();
      this.score += Math.floor(base * mult);
      this.triggerGlitch(0.08 + this.comboCount * 0.01);
    }
    triggerGlitch(amount) {
      this.glitch = Math.min(1.6, this.glitch + amount);
    }
    spawnEnemy() {
      const x = rand(40, w / devicePixelRatio - 40);
      const y = -30;
      const roll = Math.random();
      let type = 'kamikaze';
      if (this.mission && this.mission.type === 'assault') {
        if (roll < 0.4) type = 'tanky';
        else if (roll < 0.7) type = 'sniper';
        else type = 'weaver';
      } else {
        if (this.round >= 7 && roll > 0.88) type = 'sniper';
        else if (this.round >= 5 && roll > 0.72) type = 'weaver';
        else if (this.round >= 4 && roll > 0.6) type = 'tanky';
        else if (this.round >= 2 && roll > 0.35) type = 'strafer';
      }
      this.enemies.push(new Enemy(type, this.round, x, y));
    }
    spawnEnemyBullet(x, y, player, speed, color, spread = 0) {
      const dx = player.x - x;
      const dy = player.y - y;
      const d = Math.hypot(dx, dy) || 1;
      const ang = Math.atan2(dy, dx) + spread;
      const vx = Math.cos(ang) * speed;
      const vy = Math.sin(ang) * speed;
      this.enemyBullets.push(new EnemyBullet(x, y, vx, vy, color));
    }
    spawnBossBullet(x, y, ang, speed, color) {
      const vx = Math.cos(ang) * speed;
      const vy = Math.sin(ang) * speed;
      this.enemyBullets.push(new EnemyBullet(x, y, vx, vy, color));
    }
    spawnDroneBullet(x, y, target) {
      const dx = target.x - x;
      const dy = target.y - y;
      const d = Math.hypot(dx, dy) || 1;
      const vx = (dx / d) * 520;
      const vy = (dy / d) * 520;
      const b = new Bullet(x, y, vx, vy, 0);
      b.color = '#7dff6a';
      b.r = 2.5;
      b.damage = 0.7 * (1 + this.player.perkDamage);
      b.glow = 8;
      b.life = 1.6;
      this.bullets.push(b);
    }
    findNearestEnemy(x, y, maxDist) {
      let best = null;
      let bestD = maxDist;
      for (const e of this.enemies) {
        const d = Math.hypot(e.x - x, e.y - y);
        if (d < bestD) {
          bestD = d;
          best = e;
        }
      }
      if (this.boss) {
        const d = Math.hypot(this.boss.x - x, this.boss.y - y);
        if (d < bestD * 2) return this.boss;
      }
      return best;
    }
    maybeDropPowerUp(x, y) {
      const chance = 0.14;
      if (Math.random() > chance) return;
      const roll = Math.random();
      let type = 'weapon';
      if (roll < 0.25) type = 'weapon';
      else if (roll < 0.5) type = 'speed';
      else if (roll < 0.75) type = 'shield';
      else type = 'heal';
      this.powerUps.push(new PowerUp(x, y, type));
    }
    applyPowerUp(type) {
      if (type === 'weapon') this.player.power.weapon = Math.max(this.player.power.weapon, 8 + this.player.powerBonus.weapon);
      if (type === 'speed') this.player.power.speed = Math.max(this.player.power.speed, 6 + this.player.powerBonus.speed);
      if (type === 'shield') this.player.power.shield = Math.max(this.player.power.shield, 6 + this.player.powerBonus.shield);
      if (type === 'heal') this.player.health = Math.min(this.player.maxHealth, this.player.health + 25);
      if (audio) audio.playPowerUp();
      this.triggerGlitch(0.25);
      haptic([8, 30, 8]);
    }
    spawnBoss() {
      this.boss = new Boss();
    }
    addExplosion(x, y, color) {
      for (let i = 0; i < 18; i++) {
        this.particles.push(new Particle(x, y, color, rand(2, 4), rand(0.4, 0.9)));
      }
    }
    takeDamage(amount) {
      if (this.player.invuln > 0) return;
      const shielded = this.player.power.shield > 0;
      const finalDamage = shielded ? amount * 0.35 : amount;
      this.player.health = Math.max(0, this.player.health - finalDamage);
      this.shake = 0.2;
      this.shakePower = 6;
      this.player.invuln = 0.35;
      this.comboCount = 0;
      this.comboTimer = 0;
      this.triggerGlitch(0.2);
      haptic(18);
      if (this.player.health <= 0) this.state = 'over';
    }
    isOver() { return this.state !== 'play'; }
    update(dt) {
      if (this.state === 'over' || this.state === 'win') return;

      this.roundBanner -= dt;

      for (const s of this.stars) s.update(dt);
      for (const a of this.asteroids) a.update(dt);
      if (this.beacon) this.beacon.update(dt);
      if (this.glitch > 0) this.glitch = Math.max(0, this.glitch - dt * 1.2);
      if (this.comboTimer > 0) {
        this.comboTimer -= dt;
        if (this.comboTimer <= 0) this.comboCount = 0;
      }

      if (this.state === 'intro') {
        for (const p of this.particles) p.update(dt);
        this.particles = this.particles.filter(p => p.life > 0);
        return;
      }

      if (this.state === 'upgrade') {
        for (const p of this.particles) p.update(dt);
        this.particles = this.particles.filter(p => p.life > 0);
        return;
      }

      if (this.round < 10) {
        this.spawnTimer -= dt;
        const spawnRateBase = Math.max(0.35, 1.1 - this.round * 0.07);
        const spawnRate = this.mission && this.mission.type === 'survive' ? spawnRateBase * 0.8
          : this.mission && this.mission.type === 'defend' ? spawnRateBase * 0.85
          : spawnRateBase;
        const maxEnemies = 4 + Math.floor(this.round * 1.4) + (this.mission && this.mission.type !== 'eliminate' ? 2 : 0);
        const canSpawn = this.mission && this.mission.type === 'survive'
          ? this.mission.timer > 0
          : this.mission && this.mission.type === 'defend'
            ? this.mission.timer > 0
            : this.mission && this.mission.type === 'assault'
              ? this.mission.eliteKills < this.mission.target
              : this.killed < this.roundGoal;
        if (canSpawn && this.enemies.length < maxEnemies && this.spawnTimer <= 0) {
          this.spawnEnemy();
          this.spawnTimer = spawnRate;
        }
      } else if (!this.boss) {
        this.spawnBoss();
      }

      this.player.update(dt, this, input);

      for (const e of this.enemies) e.update(dt, this.player, this);
      if (this.boss) this.boss.update(dt, this, this.player);

      for (const b of this.bullets) b.update(dt);
      for (const eb of this.enemyBullets) eb.update(dt);
      for (const pu of this.powerUps) pu.update(dt);
      for (const p of this.particles) p.update(dt);
      for (const d of this.drones) {
        d.update(dt, this.player);
        if (d.cooldown <= 0) {
          const target = this.findNearestEnemy(d.x, d.y, 320);
          if (target) {
            d.cooldown = 0.35;
            this.spawnDroneBullet(d.x, d.y, target);
          }
        }
      }

      if (this.player.perkMagnet > 0) {
        for (const pu of this.powerUps) {
          const dx = this.player.x - pu.x;
          const dy = this.player.y - pu.y;
          const d = Math.hypot(dx, dy);
          if (d < this.player.perkMagnet) {
            pu.vx += (dx / (d || 1)) * 30 * dt;
            pu.vy += (dy / (d || 1)) * 30 * dt;
          }
        }
      }

      if (this.tutorial > 0) {
        this.tutorial = Math.max(0, this.tutorial - dt);
        if (Math.hypot(input.moveX, input.moveY) > 0.2 || input.fire || keys.Space) {
          this.tutorial = 0;
        }
      }

      this.handleCollisions();

      this.enemies = this.enemies.filter(e => {
        if (e.hp <= 0) return false;
        if (e.y > h / devicePixelRatio + 80) {
          if (this.beacon) {
            this.beacon.health = Math.max(0, this.beacon.health - 8);
          } else {
            this.takeDamage(4);
          }
          return false;
        }
        return true;
      });
      this.bullets = this.bullets.filter(b => b.life > 0 && b.y > -40 && b.y < h / devicePixelRatio + 40);
      this.enemyBullets = this.enemyBullets.filter(b => b.life > 0 && b.y > -40 && b.y < h / devicePixelRatio + 40);
      this.powerUps = this.powerUps.filter(pu => pu.life > 0 && pu.y < h / devicePixelRatio + 40);
      this.particles = this.particles.filter(p => p.life > 0);

      if (this.round < 10) {
        if (this.mission && this.mission.type === 'survive') {
          this.mission.timer = Math.max(0, this.mission.timer - dt);
          if (this.mission.timer <= 0) this.enterUpgrade();
        } else if (this.mission && this.mission.type === 'defend') {
          this.mission.timer = Math.max(0, this.mission.timer - dt);
          if (this.beacon && this.beacon.health <= 0) this.state = 'over';
          if (this.mission.timer <= 0 && this.beacon && this.beacon.health > 0) this.enterUpgrade();
        } else if (this.mission && this.mission.type === 'assault') {
          if (this.mission.eliteKills >= this.mission.target && this.enemies.length === 0) this.enterUpgrade();
        } else if (this.killed >= this.roundGoal && this.enemies.length === 0) {
          this.enterUpgrade();
        }
      }

      if (this.boss && this.boss.hp <= 0) {
        this.state = 'win';
      }

      if (this.shake > 0) this.shake -= dt;
    }
    handleCollisions() {
      const px = this.player.x;
      const py = this.player.y;
      const isElite = (e) => e.type === 'tanky' || e.type === 'sniper' || e.type === 'weaver';

      for (const a of this.asteroids) {
        const d = Math.hypot(a.x - px, a.y - py);
        if (d < a.r + this.player.r) {
          this.takeDamage(6);
          a.reset();
        }
      }

      for (const e of this.enemies) {
        const d = Math.hypot(e.x - px, e.y - py);
        if (d < e.radius + this.player.r) {
          this.takeDamage(12);
          e.hp = 0;
          this.addExplosion(e.x, e.y, '#ff3df5');
        }
      }

      if (this.beacon) {
        for (const e of this.enemies) {
          const d = Math.hypot(e.x - this.beacon.x, e.y - this.beacon.y);
          if (d < e.radius + this.beacon.r) {
            this.beacon.health = Math.max(0, this.beacon.health - 14);
            e.hp = 0;
            this.addExplosion(e.x, e.y, '#37f9ff');
          }
        }
      }

      for (const pu of this.powerUps) {
        const d = Math.hypot(pu.x - px, pu.y - py);
        if (d < pu.r + this.player.r) {
          this.applyPowerUp(pu.type);
          pu.life = 0;
        }
      }

      for (const eb of this.enemyBullets) {
        const d = Math.hypot(eb.x - px, eb.y - py);
        if (d < eb.r + this.player.r) {
          this.takeDamage(8);
          eb.life = 0;
        }
      }

      if (this.beacon) {
        for (const eb of this.enemyBullets) {
          const d = Math.hypot(eb.x - this.beacon.x, eb.y - this.beacon.y);
          if (d < eb.r + this.beacon.r) {
            this.beacon.health = Math.max(0, this.beacon.health - 6);
            eb.life = 0;
          }
        }
      }

      for (const b of this.bullets) {
        for (const e of this.enemies) {
          const d = Math.hypot(e.x - b.x, e.y - b.y);
          if (d < e.radius + b.r) {
            e.hp -= b.damage;
            b.life = 0;
            if (e.hp <= 0) {
              const baseScore = e.type === 'tanky' ? 160 : e.type === 'sniper' ? 180 : e.type === 'weaver' ? 140 : 100;
              this.addKillScore(baseScore);
              this.killed++;
              this.player.hits++;
              if (this.mission && this.mission.type === 'assault' && isElite(e)) this.mission.eliteKills += 1;
              this.addExplosion(e.x, e.y, '#ff3df5');
              this.maybeDropPowerUp(e.x, e.y);
            }
            break;
          }
        }
      }

      if (this.boss) {
        for (const b of this.bullets) {
          let hit = false;
          const cdx = (this.boss.x + this.boss.core.ox) - b.x;
          const cdy = (this.boss.y + this.boss.core.oy) - b.y;
          if (Math.hypot(cdx, cdy) < this.boss.core.r + b.r) {
            this.boss.hp -= b.damage * 2.2;
            this.score += 60;
            hit = true;
            this.addExplosion(b.x, b.y, '#ffd36a');
            this.triggerGlitch(0.12);
          } else {
            for (const hb of this.boss.hitboxes) {
              const dx = (this.boss.x + hb.ox) - b.x;
              const dy = (this.boss.y + hb.oy) - b.y;
              const d = Math.hypot(dx, dy);
              if (d < hb.r + b.r) {
                this.boss.hp -= b.damage * 0.6;
                this.score += 30;
                hit = true;
                this.addExplosion(b.x, b.y, '#37f9ff');
                break;
              }
            }
          }
          if (hit) {
            b.life = 0;
            this.player.hits++;
          }
        }

        const dBoss = Math.hypot(this.boss.x - px, this.boss.y - py);
        if (dBoss < 90) {
          this.takeDamage(18);
        }
      }
    }
    drawBackground(ctx) {
      const grd = ctx.createLinearGradient(0, 0, 0, h / devicePixelRatio);
      grd.addColorStop(0, '#05020b');
      grd.addColorStop(0.5, '#120621');
      grd.addColorStop(1, '#06020f');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, w / devicePixelRatio, h / devicePixelRatio);

      for (const s of this.stars) s.draw(ctx);

      const horizon = h / devicePixelRatio * 0.7;
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#7b5cff';
      ctx.lineWidth = 1;
      for (let i = 0; i < 18; i++) {
        const y = horizon + i * 18;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w / devicePixelRatio, y);
        ctx.stroke();
      }
      for (let i = 0; i < 18; i++) {
        const x = i * 50;
        ctx.beginPath();
        ctx.moveTo(x, horizon);
        ctx.lineTo(w / devicePixelRatio / 2, h / devicePixelRatio);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(w / devicePixelRatio - x, horizon);
        ctx.lineTo(w / devicePixelRatio / 2, h / devicePixelRatio);
        ctx.stroke();
      }
      ctx.restore();
    }
    drawHUD(ctx) {
      ctx.save();
      ctx.font = '16px monospace';
      ctx.fillStyle = '#7dff6a';
      ctx.shadowBlur = 12;
      ctx.shadowColor = '#7dff6a';
      ctx.fillText(`Round: ${this.round}`, 20, 28);
      ctx.fillText(`Score: ${this.score}`, 20, 50);
      const weaponLabel = this.player.power.weapon > 0
        ? `Weapon: ${this.player.weaponLevel + 1} (Over)`
        : `Weapon: ${this.player.weaponLevel + 1}`;
      ctx.fillText(weaponLabel, 20, 72);
      ctx.fillText(`Hits: ${this.player.hits}`, 20, 94);

      const barW = 180;
      const barH = 10;
      const healthPct = this.player.health / this.player.maxHealth;
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#1a0f2b';
      ctx.fillRect(20, 110, barW, barH);
      ctx.fillStyle = healthPct > 0.3 ? '#37f9ff' : '#ff3df5';
      ctx.fillRect(20, 110, barW * healthPct, barH);
      ctx.strokeStyle = '#7b5cff';
      ctx.strokeRect(20, 110, barW, barH);

      const p = this.player.power;
      const icons = [
        { key: 'weapon', label: 'W', color: '#ffd36a' },
        { key: 'speed', label: 'S', color: '#37f9ff' },
        { key: 'shield', label: 'D', color: '#7b5cff' }
      ];
      let px = 20;
      const py = 132;
      for (const icon of icons) {
        const t = p[icon.key];
        if (t > 0) {
          ctx.shadowBlur = 10;
          ctx.shadowColor = icon.color;
          ctx.strokeStyle = icon.color;
          ctx.fillStyle = '#1a0f2b';
          ctx.fillRect(px, py, 36, 8);
          ctx.fillStyle = icon.color;
          const maxTime = icon.key === 'weapon'
            ? 8 + this.player.powerBonus.weapon
            : 6 + this.player.powerBonus[icon.key];
          ctx.fillRect(px, py, clamp(t / maxTime, 0, 1) * 36, 8);
          ctx.strokeRect(px, py, 36, 8);
          ctx.fillStyle = icon.color;
          ctx.fillText(icon.label, px + 14, py + 20);
          px += 48;
        }
      }
      if (p.weapon <= 0 && p.speed <= 0 && p.shield <= 0) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#7b5cff';
        ctx.fillText('Power: --', 20, 150);
      }

      const objectiveX = w / devicePixelRatio - 320;
      ctx.shadowBlur = 10;
      ctx.shadowColor = '#37f9ff';
      ctx.fillStyle = '#37f9ff';
      let obj = '';
      if (this.mission) {
        if (this.mission.type === 'eliminate') obj = `Objective: Eliminate ${this.killed}/${this.roundGoal}`;
        if (this.mission.type === 'survive') obj = `Objective: Survive ${Math.ceil(this.mission.timer)}s`;
        if (this.mission.type === 'defend') obj = `Objective: Defend Core ${Math.ceil(this.mission.timer)}s`;
        if (this.mission.type === 'assault') obj = `Objective: Elite Kills ${this.mission.eliteKills}/${this.mission.target}`;
        if (this.mission.type === 'boss') obj = 'Objective: Defeat the Boss';
      }
      if (obj) ctx.fillText(obj, objectiveX, 28);

      if (this.mission && this.mission.type === 'defend' && this.beacon) {
        const bW = 160;
        const bH = 8;
        const pct = this.beacon.health / this.beacon.maxHealth;
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#1a0f2b';
        ctx.fillRect(objectiveX, 40, bW, bH);
        ctx.fillStyle = '#ff3df5';
        ctx.fillRect(objectiveX, 40, bW * pct, bH);
        ctx.strokeStyle = '#37f9ff';
        ctx.strokeRect(objectiveX, 40, bW, bH);
      }

      if (this.comboCount > 1) {
        ctx.shadowBlur = 16;
        ctx.shadowColor = '#ffd36a';
        ctx.fillStyle = '#ffd36a';
        ctx.fillText(`Combo x${this.comboCount} (x${this.getComboMult().toFixed(1)})`, objectiveX, 60);
      }
      if (this.drones.length > 0) {
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#7dff6a';
        ctx.fillStyle = '#7dff6a';
        ctx.fillText(`Drones: ${this.drones.length}`, objectiveX, 82);
      }

      if (this.state === 'upgrade') {
        ctx.save();
        ctx.fillStyle = 'rgba(5, 2, 11, 0.85)';
        ctx.fillRect(0, 0, w / devicePixelRatio, h / devicePixelRatio);
        ctx.font = '26px monospace';
        ctx.fillStyle = '#37f9ff';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#37f9ff';
        ctx.fillText('Choose Upgrade', w / devicePixelRatio / 2 - 120, h / devicePixelRatio / 2 - 120);
        ctx.font = '18px monospace';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff3df5';
        const startY = h / devicePixelRatio / 2 - 60;
        for (let i = 0; i < this.upgradeChoices.length; i++) {
          const u = this.upgradeChoices[i];
          const lineY = startY + i * 48;
          ctx.fillStyle = 'rgba(15, 6, 24, 0.8)';
          ctx.fillRect(w / devicePixelRatio / 2 - 190, lineY - 18, 380, 36);
          ctx.strokeStyle = '#37f9ff';
          ctx.strokeRect(w / devicePixelRatio / 2 - 190, lineY - 18, 380, 36);
          ctx.fillStyle = '#ff3df5';
          ctx.fillText(`${i + 1}. ${u.name}`, w / devicePixelRatio / 2 - 170, lineY);
          ctx.fillStyle = '#7dff6a';
          ctx.fillText(u.desc, w / devicePixelRatio / 2 - 150, lineY + 18);
        }
        ctx.font = '14px monospace';
        ctx.fillStyle = '#7b5cff';
        ctx.fillText('Tap or Press 1-3', w / devicePixelRatio / 2 - 70, h / devicePixelRatio / 2 + 100);
        ctx.restore();
      }

      if (this.state === 'intro') {
        ctx.save();
        ctx.fillStyle = 'rgba(5, 2, 11, 0.85)';
        ctx.fillRect(0, 0, w / devicePixelRatio, h / devicePixelRatio);
        ctx.font = '30px monospace';
        ctx.fillStyle = '#37f9ff';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#37f9ff';
        ctx.fillText('NEON VOID', w / devicePixelRatio / 2 - 110, h / devicePixelRatio / 2 - 90);
        ctx.font = '16px monospace';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff3df5';
        if (isTouchDevice) {
          ctx.fillStyle = '#ff3df5';
          ctx.fillText('Left thumb: Move', w / devicePixelRatio / 2 - 90, h / devicePixelRatio / 2 - 30);
          ctx.fillText('Auto-fire enabled', w / devicePixelRatio / 2 - 90, h / devicePixelRatio / 2 - 10);
          ctx.fillText('Tap upgrades between rounds', w / devicePixelRatio / 2 - 140, h / devicePixelRatio / 2 + 10);
          ctx.fillStyle = '#7dff6a';
          ctx.fillText('Tap to Start', w / devicePixelRatio / 2 - 60, h / devicePixelRatio / 2 + 50);
        } else {
          ctx.fillStyle = '#ff3df5';
          ctx.fillText('Move: Arrow Keys', w / devicePixelRatio / 2 - 90, h / devicePixelRatio / 2 - 30);
          ctx.fillText('Fire: Space', w / devicePixelRatio / 2 - 60, h / devicePixelRatio / 2 - 10);
          ctx.fillText('Upgrades: 1-3', w / devicePixelRatio / 2 - 70, h / devicePixelRatio / 2 + 10);
          ctx.fillStyle = '#7dff6a';
          ctx.fillText('Press Enter/Space', w / devicePixelRatio / 2 - 80, h / devicePixelRatio / 2 + 50);
        }
        ctx.restore();
      }

      if (this.state === 'play' && this.tutorial > 0) {
        const alpha = clamp(this.tutorial / 5.5, 0, 1);
        ctx.save();
        ctx.globalAlpha = 0.7 * alpha;
        ctx.fillStyle = 'rgba(8, 4, 18, 0.6)';
        ctx.fillRect(0, 0, w / devicePixelRatio, h / devicePixelRatio);
        ctx.font = '16px monospace';
        ctx.shadowBlur = 12;
        ctx.shadowColor = '#37f9ff';
        if (isTouchDevice) {
          ctx.fillStyle = '#37f9ff';
          ctx.fillText('Move', 24, h / devicePixelRatio - 140);
          ctx.fillText('Auto-fire', w / devicePixelRatio - 140, h / devicePixelRatio - 140);
          ctx.strokeStyle = '#37f9ff';
          ctx.beginPath();
          ctx.arc(90, h / devicePixelRatio - 90, 50, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(w / devicePixelRatio - 90, h / devicePixelRatio - 90, 36, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          ctx.fillStyle = '#37f9ff';
          ctx.fillText('Move: Arrow Keys', w / devicePixelRatio / 2 - 90, h / devicePixelRatio / 2 - 10);
          ctx.fillText('Fire: Space', w / devicePixelRatio / 2 - 55, h / devicePixelRatio / 2 + 12);
        }
        ctx.restore();
      }

      const vw = w / devicePixelRatio;
      const vh = h / devicePixelRatio;
      if (settings.portraitOnly && vw > vh) {
        ctx.save();
        ctx.fillStyle = 'rgba(5, 2, 11, 0.8)';
        ctx.fillRect(0, 0, vw, vh);
        ctx.font = '24px monospace';
        ctx.fillStyle = '#37f9ff';
        ctx.shadowBlur = 16;
        ctx.shadowColor = '#37f9ff';
        ctx.fillText('Rotate to Portrait', vw / 2 - 110, vh / 2);
        ctx.restore();
      }

      if (!isStandalone()) {
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#37f9ff';
        ctx.fillStyle = '#37f9ff';
        const bx = w / devicePixelRatio - 150;
        const by = h / devicePixelRatio - 36;
        if (canInstall) {
          ctx.fillStyle = 'rgba(10, 8, 20, 0.7)';
          ctx.fillRect(bx - 10, by - 20, 140, 28);
          ctx.strokeStyle = '#37f9ff';
          ctx.strokeRect(bx - 10, by - 20, 140, 28);
          ctx.fillStyle = '#37f9ff';
          ctx.fillText('Install', bx + 30, by);
        } else if (isIos) {
          ctx.fillStyle = '#7dff6a';
          ctx.fillText('iOS: Share  Add to Home Screen', 20, h / devicePixelRatio - 20);
        }
      }

      if (this.roundBanner > 0) {
        ctx.font = '32px monospace';
        ctx.fillStyle = '#ff3df5';
        ctx.shadowBlur = 22;
        ctx.shadowColor = '#ff3df5';
        ctx.fillText(`ROUND ${this.round}`, w / devicePixelRatio / 2 - 90, 80);
      }
      if (this.state === 'over') {
        ctx.font = '40px monospace';
        ctx.fillStyle = '#ff3df5';
        ctx.shadowBlur = 24;
        ctx.shadowColor = '#ff3df5';
        ctx.fillText('GAME OVER', w / devicePixelRatio / 2 - 120, h / devicePixelRatio / 2);
        ctx.font = '16px monospace';
        const restartLabel = isTouchDevice ? 'Tap to Restart' : 'Press Enter to Restart';
        ctx.fillText(restartLabel, w / devicePixelRatio / 2 - 110, h / devicePixelRatio / 2 + 30);
      }
      if (this.state === 'win') {
        ctx.font = '40px monospace';
        ctx.fillStyle = '#7dff6a';
        ctx.shadowBlur = 24;
        ctx.shadowColor = '#7dff6a';
        ctx.fillText('NEON VOID CLEARED', w / devicePixelRatio / 2 - 190, h / devicePixelRatio / 2);
        ctx.font = '16px monospace';
        const restartLabel = isTouchDevice ? 'Tap to Restart' : 'Press Enter to Restart';
        ctx.fillText(restartLabel, w / devicePixelRatio / 2 - 110, h / devicePixelRatio / 2 + 30);
      }
      ctx.restore();
    }
    render(ctx) {
      const shakeX = this.shake > 0 ? rand(-this.shakePower, this.shakePower) : 0;
      const shakeY = this.shake > 0 ? rand(-this.shakePower, this.shakePower) : 0;
      ctx.save();
      ctx.translate(shakeX, shakeY);

      this.drawBackground(ctx);
      for (const a of this.asteroids) a.draw(ctx);
      if (this.beacon) this.beacon.draw(ctx);
      for (const pu of this.powerUps) pu.draw(ctx);
      for (const e of this.enemies) e.draw(ctx);
      if (this.boss) {
        this.boss.draw(ctx);
        const hpPct = Math.max(0, this.boss.hp / this.boss.maxHp);
        ctx.save();
        ctx.fillStyle = '#1a0f2b';
        ctx.fillRect(w / devicePixelRatio / 2 - 140, 20, 280, 10);
        ctx.fillStyle = '#ff3df5';
        ctx.fillRect(w / devicePixelRatio / 2 - 140, 20, 280 * hpPct, 10);
        ctx.strokeStyle = '#37f9ff';
        ctx.strokeRect(w / devicePixelRatio / 2 - 140, 20, 280, 10);
        ctx.restore();
      }

      for (const eb of this.enemyBullets) eb.draw(ctx);
      for (const b of this.bullets) b.draw(ctx);
      for (const p of this.particles) p.draw(ctx);
      for (const d of this.drones) d.draw(ctx);
      this.player.draw(ctx);

      if (input.usingTouch && (joystick.active || Math.hypot(input.moveX, input.moveY) > 0.1)) {
        const baseX = joystick.active ? joystick.startX : 90;
        const baseY = joystick.active ? joystick.startY : h / devicePixelRatio - 120;
        const knobX = joystick.active ? joystick.x : baseX + input.moveX * joystick.radius;
        const knobY = joystick.active ? joystick.y : baseY + input.moveY * joystick.radius;
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.strokeStyle = '#37f9ff';
        ctx.shadowBlur = 12;
        ctx.shadowColor = '#37f9ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(baseX, baseY, joystick.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(knobX, knobY, 16, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      if (this.glitch > 0) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.15 + this.glitch * 0.35;
        for (let i = 0; i < 6; i++) {
          const gh = 4 + Math.random() * 8;
          const gy = Math.random() * (h / devicePixelRatio);
          const gx = (Math.random() - 0.5) * this.glitch * 20;
          ctx.fillStyle = i % 2 ? '#37f9ff' : '#ff3df5';
          ctx.fillRect(gx, gy, w / devicePixelRatio, gh);
        }
        ctx.restore();
      }

      ctx.restore();
      this.drawHUD(ctx);
    }
    restart() {
      this.player = new Player();
      this.bullets = [];
      this.enemyBullets = [];
      this.enemies = [];
      this.powerUps = [];
      this.particles = [];
      this.asteroids = Array.from({ length: 5 }, () => new Asteroid());
      this.drones = [];
      this.beacon = null;
      this.mission = null;
      this.round = 1;
      this.score = 0;
      this.killed = 0;
      this.spawnTimer = 0;
      this.roundGoal = this.getRoundGoal();
      this.boss = null;
      this.state = 'play';
      this.roundBanner = 2.4;
      this.comboCount = 0;
      this.comboTimer = 0;
      this.glitch = 0;
      this.upgradePool = this.buildUpgradePool();
      this.upgradeChoices = [];
      this.pendingRound = null;
      this.setupRound(this.round);
    }
  }

  const game = new Game();
  let last = performance.now();
  function updateKeyboardInput() {
    let ix = 0, iy = 0;
    if (keys.ArrowLeft) ix -= 1;
    if (keys.ArrowRight) ix += 1;
    if (keys.ArrowUp) iy -= 1;
    if (keys.ArrowDown) iy += 1;
    const mag = Math.hypot(ix, iy) || 1;
    if (!input.usingTouch || !joystick.active) {
      input.moveX = ix / mag;
      input.moveY = iy / mag;
    }
    if (!input.usingTouch) input.fire = keys.Space;
  }

  function setJoystick(x, y) {
    const dx = x - joystick.startX;
    const dy = y - joystick.startY;
    const dist = Math.hypot(dx, dy);
    const max = joystick.radius;
    const norm = dist > max ? max / dist : 1;
    const nx = (dx * norm) / max;
    const ny = (dy * norm) / max;
    const dead = 0.08;
    input.moveX = Math.abs(nx) < dead ? 0 : nx;
    input.moveY = Math.abs(ny) < dead ? 0 : ny;
    joystick.x = joystick.startX + dx * norm;
    joystick.y = joystick.startY + dy * norm;
  }

  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    input.usingTouch = e.pointerType === 'touch' || e.pointerType === 'pen';
    if (audio) audio.ensure();
    if (game.state === 'over' || game.state === 'win') {
      game.restart();
      return;
    }
    if (game.state === 'intro') {
      game.state = 'play';
      game.tutorial = 5.5;
      return;
    }
    if (game.state === 'upgrade') {
      game.handleUpgradeTap(x, y, rect.width, rect.height);
      return;
    }
    if (canInstall && !isStandalone()) {
      const bx = rect.width - 150;
      const by = rect.height - 36;
      if (x >= bx - 10 && x <= bx + 130 && y >= by - 20 && y <= by + 8) {
        if (installPrompt) installPrompt.prompt();
        return;
      }
    }
    if (x < rect.width * 0.45) {
      joystick.active = true;
      joystick.id = e.pointerId;
      joystick.startX = x;
      joystick.startY = y;
      joystick.x = x;
      joystick.y = y;
      setJoystick(x, y);
    } else {
      input.fire = true;
    }
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointermove', (e) => {
    if (!joystick.active || e.pointerId !== joystick.id) return;
    const rect = canvas.getBoundingClientRect();
    setJoystick(e.clientX - rect.left, e.clientY - rect.top);
  });
  function endPointer(e) {
    if (joystick.active && e.pointerId === joystick.id) {
      joystick.active = false;
      input.moveX = 0;
      input.moveY = 0;
    }
    input.fire = false;
  }
  canvas.addEventListener('pointerup', endPointer);
  canvas.addEventListener('pointercancel', endPointer);

  function loop(ts) {
    const dt = Math.min(0.033, (ts - last) / 1000);
    last = ts;
    updateKeyboardInput();
    if (keys.Enter && (game.state === 'over' || game.state === 'win')) {
      game.restart();
      keys.Enter = false;
    }
    if ((keys.Enter || keys.Space) && game.state === 'intro') {
      game.state = 'play';
      game.tutorial = 5.5;
      keys.Enter = false;
      keys.Space = false;
    }
    if (game.state === 'upgrade') {
      if (keys.Digit1 || keys.Numpad1) {
        game.applyUpgrade(0);
        keys.Digit1 = false;
        keys.Numpad1 = false;
      } else if (keys.Digit2 || keys.Numpad2) {
        game.applyUpgrade(1);
        keys.Digit2 = false;
        keys.Numpad2 = false;
      } else if (keys.Digit3 || keys.Numpad3) {
        game.applyUpgrade(2);
        keys.Digit3 = false;
        keys.Numpad3 = false;
      }
    }
    game.update(dt);
    game.render(ctx);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(() => {});
    });
  }
})();
</script>
</body>
</html>
